"""
SpecCompiler - Deterministic transformation of TestSpec to Java code.

This compiler takes a TestSpec (structured JSON) and produces valid Java test code.
The transformation is deterministic: same spec = same output.

Key benefits:
1. Zero syntax hallucinations - Java syntax is generated by code, not LLM
2. Correct @Mock/@InjectMocks patterns always
3. Proper imports always included
4. Consistent code style
5. Mockito matcher consistency enforced
"""

import re
from ..models import DslTestSpec, DslTestCaseSpec, Assertion, MockSetup


class SpecCompiler:
    """
    Compile TestSpec to Java test code.

    This is the deterministic part of the pipeline - the LLM generates
    semantic intent (what to test), and the compiler handles syntax.
    """

    # Standard imports for Mockito/JUnit tests
    STANDARD_IMPORTS = [
        "import org.junit.jupiter.api.Test;",
        "import org.junit.jupiter.api.DisplayName;",
        "import org.junit.jupiter.api.extension.ExtendWith;",
        "import org.mockito.InjectMocks;",
        "import org.mockito.Mock;",
        "import org.mockito.junit.jupiter.MockitoExtension;",
        "import static org.junit.jupiter.api.Assertions.*;",
        "import static org.mockito.Mockito.*;",
        "import static org.mockito.ArgumentMatchers.*;",
        # Common types used in Spring tests
        "import java.util.*;",
        "import org.mockito.Mockito;",
        "import org.springframework.data.domain.Page;",
        "import org.springframework.data.domain.PageImpl;",
        "import org.springframework.data.domain.PageRequest;",
        "import org.springframework.data.domain.Pageable;",
        "import org.springframework.ui.Model;",
        "import org.springframework.web.bind.WebDataBinder;",
        "import org.springframework.web.servlet.mvc.support.RedirectAttributes;",
        "import org.springframework.validation.BindingResult;",
    ]

    def compile(self, spec: DslTestSpec) -> str:
        """
        Transform TestSpec to complete Java test class.

        Args:
            spec: The test specification to compile

        Returns:
            Complete Java test class as a string
        """
        lines = []

        # Package declaration
        lines.append(f"package {spec.package_name};")
        lines.append("")

        # Imports
        lines.extend(self.STANDARD_IMPORTS)
        lines.append("")

        # Additional imports (entity classes, etc.)
        for imp in spec.additional_imports:
            if not imp.endswith(";"):
                imp = imp + ";"
            if not imp.startswith("import "):
                imp = "import " + imp
            lines.append(imp)
        if spec.additional_imports:
            lines.append("")

        # Class declaration
        lines.append("@ExtendWith(MockitoExtension.class)")
        lines.append(f"class {spec.class_under_test}Test {{")
        lines.append("")

        # Mock fields
        for dep in spec.dependencies:
            lines.append("    @Mock")
            lines.append(f"    private {dep.type} {dep.name};")
            lines.append("")

        # InjectMocks field
        lines.append("    @InjectMocks")
        lines.append(f"    private {spec.class_under_test} controller;")
        lines.append("")

        # Test methods
        for tc in spec.test_cases:
            lines.append(self._compile_test_case(tc))
            lines.append("")

        # Close class
        lines.append("}")

        return "\n".join(lines)

    def _compile_test_case(self, tc: DslTestCaseSpec) -> str:
        """Compile a single test case to a @Test method."""
        lines = []

        # Annotations
        lines.append("    @Test")
        # Escape quotes in description
        description = tc.description.replace('"', '\\"')
        lines.append(f'    @DisplayName("{description}")')
        lines.append(f"    void {tc.name}() throws Exception {{")

        # Track declared variables and renames to fix collisions
        declared_vars = set()
        renames = {}  # old_name -> new_name

        # First pass: collect all renames needed
        for stmt in tc.arrange:
            self._collect_variable_renames(stmt, declared_vars, renames)

        # Second pass: apply renames to all statements
        for stmt in tc.arrange:
            # Ensure statement ends with semicolon
            stmt = stmt.rstrip(";") + ";"
            # Apply all renames
            for old_name, new_name in renames.items():
                stmt = re.sub(rf'\b{old_name}\b', new_name, stmt)
            lines.append(f"        {stmt}")

        # Arrange: mock setups (after variables are declared)
        # Deduplicate mock setups to avoid Mockito strict mode errors
        seen_mock_lines = set()
        for mock in tc.mocks:
            mock_line = self._compile_mock_setup(mock)
            # Apply renames to mock setup
            for old_name, new_name in renames.items():
                mock_line = re.sub(rf'\b{old_name}\b', new_name, mock_line)
            # Skip duplicates
            if mock_line not in seen_mock_lines:
                seen_mock_lines.add(mock_line)
                lines.append(f"        {mock_line}")

        # Empty line before Act if we had Arrange
        if tc.mocks or tc.arrange:
            lines.append("")

        # Check if this test has a throws assertion - if so, skip direct action call
        # because assertThrows will contain the call
        has_throws_assertion = any(a.type == "throws" for a in tc.assertions)

        # Act: method call - apply renames to action args
        action = tc.action
        renamed_args = []
        for arg in action.args:
            for old_name, new_name in renames.items():
                arg = re.sub(rf'\b{old_name}\b', new_name, arg)
            renamed_args.append(arg)
        args = ", ".join(renamed_args)

        if not has_throws_assertion:
            if action.returns_to:
                lines.append(f"        var {action.returns_to} = {action.object}.{action.method}({args});")
            else:
                lines.append(f"        {action.object}.{action.method}({args});")
            # Empty line before Assert
            lines.append("")

        # Assert - apply renames to assertions
        # Collect valid mock names from arrange statements for validation
        valid_mocks = set()
        for stmt in tc.arrange:
            # Match: Type varName = mock(Type.class) or Type varName = Mockito.mock(...)
            mock_decl = re.search(r'(\w+)\s*=\s*(?:Mockito\.)?mock\(', stmt)
            if mock_decl:
                valid_mocks.add(mock_decl.group(1))

        for assertion in tc.assertions:
            assertion_line = self._compile_assertion(
                assertion,
                returns_to=action.returns_to,
                valid_mocks=valid_mocks
            )
            if assertion_line is None:
                continue  # Skip invalid assertions
            for old_name, new_name in renames.items():
                # Don't rename the action return variable in assertions
                # If the old_name matches returns_to, it's the action result, not the renamed arrange variable
                if old_name == action.returns_to:
                    continue
                assertion_line = re.sub(rf'\b{old_name}\b', new_name, assertion_line)
            lines.append(f"        {assertion_line}")

        lines.append("    }")

        return "\n".join(lines)

    def _compile_mock_setup(self, mock: MockSetup) -> str:
        """Compile a mock setup (when/thenReturn or doThrow/when)."""
        args = self._fix_matcher_consistency(mock.args) if mock.args else ""

        if mock.throws:
            # doThrow pattern for exceptions
            return f"doThrow(new {mock.throws}()).when({mock.mock_name}).{mock.method}({args});"
        elif mock.returns is not None:
            # when/thenReturn pattern
            return f"when({mock.mock_name}.{mock.method}({args})).thenReturn({mock.returns});"
        else:
            # void method - no setup needed, just verify later
            return f"// {mock.mock_name}.{mock.method} is void, will verify after call"

    def _compile_assertion(
        self,
        a: Assertion,
        returns_to: str | None = None,
        valid_mocks: set | None = None
    ) -> str | None:
        """Compile an assertion to Java code.

        Args:
            a: The assertion to compile
            returns_to: The variable name for action return value (usually "result")
            valid_mocks: Set of valid mock variable names from arrange

        Returns:
            Java assertion code, or None if assertion should be skipped
        """
        if a.type == "equals":
            # Fix common LLM error: using wrong variable as actual
            actual = a.actual
            if returns_to and actual != returns_to:
                # Check if actual looks like a mock variable (common mistake)
                # If so, replace with the correct result variable
                if actual and re.match(r'^[a-z]\w*$', actual) and actual != "result":
                    actual = returns_to
            return f"assertEquals({a.expected}, {actual});"

        elif a.type == "not_null":
            return f"assertNotNull({a.actual});"

        elif a.type == "true":
            return f"assertTrue({a.actual});"

        elif a.type == "false":
            return f"assertFalse({a.actual});"

        elif a.type == "throws":
            return f"assertThrows({a.exception}.class, {a.actual});"

        elif a.type == "verify":
            # Validate mock_name exists in valid_mocks
            if valid_mocks and a.mock_name and a.mock_name not in valid_mocks:
                # Skip verify on undeclared mocks
                return None
            # For verify(), use any() for numeric args to avoid int/long type mismatches
            args = self._fix_verify_args(a.args) if a.args else ""
            return f"verify({a.mock_name}).{a.method}({args});"

        else:
            return f"// Unknown assertion type: {a.type}"

    # Mockito matcher patterns that require all args to be matchers
    MATCHER_PATTERNS = [
        r'\bany\s*\(',
        r'\banyString\s*\(',
        r'\banyInt\s*\(',
        r'\banyLong\s*\(',
        r'\banyBoolean\s*\(',
        r'\banyList\s*\(',
        r'\banyMap\s*\(',
        r'\banySet\s*\(',
        r'\beq\s*\(',
        r'\bargThat\s*\(',
        r'\bisA\s*\(',
        r'\bsame\s*\(',
        r'\bnotNull\s*\(',
        r'\bisNull\s*\(',
    ]

    def _fix_matcher_consistency(self, args: list[str]) -> str:
        """
        Fix Mockito matcher consistency: if ANY arg uses a matcher, ALL must.

        Mockito rule: You cannot mix raw values with matchers.
        Wrong:  verify(mock).method("raw", any())
        Right:  verify(mock).method(eq("raw"), any())

        This method detects if any argument uses a matcher and wraps
        raw string/number literals with eq().
        """
        if not args:
            return ""

        # Check if any argument contains a matcher
        has_matcher = False
        for arg in args:
            for pattern in self.MATCHER_PATTERNS:
                if re.search(pattern, arg):
                    has_matcher = True
                    break
            if has_matcher:
                break

        if not has_matcher:
            # No matchers, return as-is
            return ", ".join(args)

        # Has matchers - wrap raw values with eq()
        fixed_args = []
        for arg in args:
            # Check if this arg already uses a matcher
            is_matcher = any(re.search(p, arg) for p in self.MATCHER_PATTERNS)

            if is_matcher:
                fixed_args.append(arg)
            elif self._is_raw_literal(arg):
                # Wrap raw literals with eq()
                fixed_args.append(f"eq({arg})")
            else:
                # Variable reference - wrap with eq() to be safe
                fixed_args.append(f"eq({arg})")

        return ", ".join(fixed_args)

    def _fix_verify_args(self, args: list[str]) -> str:
        """
        Fix verify() arguments to avoid type mismatches.

        Mockito verify() is strict about types - Integer vs Long, etc.
        To avoid failures due to LLM not knowing exact return types,
        we use any() for numeric arguments and eq() for strings.

        Examples:
            verify(model).addAttribute("totalItems", 2)  # Fails if actual is 2L
            verify(model).addAttribute(eq("totalItems"), any())  # Works
        """
        if not args:
            return ""

        fixed_args = []
        for arg in args:
            arg = arg.strip()

            # Already a matcher - keep as-is
            if any(re.search(p, arg) for p in self.MATCHER_PATTERNS):
                fixed_args.append(arg)
            # String literal - use eq() for exact match
            elif arg.startswith('"') and arg.endswith('"'):
                fixed_args.append(f"eq({arg})")
            # Numeric literal (int, long, float) - use any() to avoid type issues
            elif re.match(r'^-?\d+\.?\d*[LlFfDd]?$', arg):
                fixed_args.append("any()")
            # Boolean - use eq()
            elif arg in ('true', 'false'):
                fixed_args.append(f"eq({arg})")
            # null - use isNull()
            elif arg == 'null':
                fixed_args.append("isNull()")
            # Variable reference - use eq()
            else:
                fixed_args.append(f"eq({arg})")

        return ", ".join(fixed_args)

    def _is_raw_literal(self, arg: str) -> bool:
        """Check if argument is a raw literal (string, number, boolean)."""
        arg = arg.strip()
        # String literal
        if arg.startswith('"') and arg.endswith('"'):
            return True
        # Number literal
        if re.match(r'^-?\d+\.?\d*[LlFfDd]?$', arg):
            return True
        # Boolean
        if arg in ('true', 'false'):
            return True
        # null
        if arg == 'null':
            return True
        return False

    def _collect_variable_renames(self, stmt: str, declared_vars: set, renames: dict) -> None:
        """
        Collect variable renames needed to avoid collisions.

        The action result is always named 'result', so if arrange declares
        a variable named 'result', we need to rename it everywhere.
        """
        # Pattern to detect variable declaration: Type varName = ...
        decl_pattern = r'^(\w+(?:<[^>]+>)?)\s+(\w+)\s*='
        match = re.match(decl_pattern, stmt.strip())

        if match:
            var_type = match.group(1)
            var_name = match.group(2)

            # Check for collision with reserved 'result' or already declared vars
            if var_name == 'result':
                # Rename to type-based name (e.g., BindingResult -> bindingResult)
                new_name = var_type[0].lower() + var_type[1:]
                # Handle generic types: List<Pet> -> listVar
                if '<' in new_name:
                    new_name = new_name.split('<')[0] + 'Var'
                # Ensure unique
                base_name = new_name
                counter = 1
                while new_name in declared_vars or new_name in renames.values():
                    new_name = f"{base_name}{counter}"
                    counter += 1
                declared_vars.add(new_name)
                renames[var_name] = new_name
            elif var_name in declared_vars:
                # Duplicate variable - rename with suffix
                base_name = var_name
                counter = 2
                new_name = f"{base_name}{counter}"
                while new_name in declared_vars or new_name in renames.values():
                    counter += 1
                    new_name = f"{base_name}{counter}"
                declared_vars.add(new_name)
                renames[var_name] = new_name
            else:
                declared_vars.add(var_name)

    def compile_partial(self, spec: DslTestSpec) -> tuple[str, str, str]:
        """
        Compile to separate parts: header, test methods, footer.

        Useful for incremental generation where we might need to
        regenerate just the test methods.

        Returns:
            Tuple of (header, methods, footer)
        """
        full = self.compile(spec)
        lines = full.split("\n")

        # Find where test methods start (after @InjectMocks line + blank)
        header_end = 0
        for i, line in enumerate(lines):
            if "@InjectMocks" in line:
                header_end = i + 3  # Skip @InjectMocks, field declaration, blank line
                break

        # Find where test methods end (before closing brace)
        footer_start = len(lines) - 1

        header = "\n".join(lines[:header_end])
        methods = "\n".join(lines[header_end:footer_start])
        footer = "\n".join(lines[footer_start:])

        return header, methods, footer
